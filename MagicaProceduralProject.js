
//Scroll down to the botton and uncomment the last line in order to trigger
//the export to .vox file function


function VOX(X, Y, Z) {
  //established the basic properties that will characterize the file during programatic generation of data. X,Y, and Z indicate the dimensions of the vox building area. vcount indicates the number of voxels in the model while this.voxels is an array for storing the information about individual voxels. this.palette is an array for storing the indexed colors which will make up the model. There can be no more than 256 and does not have to be manually generated by the user. If no palette information is contained then MagicaVoxel will supply a default one.
  this.X = X;
  this.Y = Y;
  this.Z = Z;
  this.vcount = 0
  this.voxels = [];
  this.palette = [];

  //creates a greyscale color palette
  for (var i = 256; --i > -1;) {
    this.palette.push(0xff000000 | i | (i << 8) | (i << 16));
  }

  // a setter function for creating new voxels and for deleting old ones
  this.setVoxel = function(x, y, z, i) {
    i |= 0;
    x |= 0;
    y |= 0;
    z |= 0;

    if (i >= 0 && i < 256 && x >= 0 && y >= 0 && z >= 0 && x < this.X && y < this.Y && z < this.Z) {
      var key = x + "_" + y + "_" + z;
      if (i > 0) {
        if (!this.voxels[key]) this.vcount++;
        this.voxels[key] = i;
      } else {
        if (this.voxels[key]) this.vcount--;
        delete this.voxels[key];

      }
    }
  }


  // a getter function for the color index of the voxel.
  this.getVoxel = function(x, y, z) {
    x |= 0;
    y |= 0;
    z |= 0;

    if (x >= 0 && y >= 0 && z >= 0 && x < this.X && z < this.Y && z < this.Z) {
      let key = x + "_" + y + "_" + z;
      //return the color index of the voxel if the voxel exists.
      if(this.voxels[key]) {
        console.log('should indicate a voxel');
        return this.voxels[key];
      }
      // if the voxel does not exist then return false.
      else if(!this.voxels[key]) {
        console.log("should indicate no voxel!");
        return false;
      }
    }
  }

  this.getVoxelRGBA = function(x, y, z) {
    x |= 0;
    y |= 0;
    z |= 0;

    if (x >= 0 && y >= 0 && z >= 0 && x < this.X && z < this.Y && z < this.Z) {
      let key = x + "_" + y + "_" + z;
      if(this.voxels[key]) {
        return (this.palette[this.voxels[key]] >>> 0).toString(16);
      }
      else if(!this.voxels[key]) {
        console.log("No voxel at location ("+ x + ", " + y + ", " + z + ")");
        return false;
      }
    }    
  }

  // every character of a string must be converted to a byte of data which is given by the function charCodeAt which returns the UTF-16 value-- equivilent to the utf8 enocoding for all points inside the BMP
  this.appendString = function(data, str) {
    for (var i = 0, j = str.length; i < j; ++i) {
      data.push(str.charCodeAt(i));
    }
  }

  // the RIFF is little endian by the standards of the protocal and must therefore the data must be reversed on a byte wise basis. 
  this.appendUInt32 = function(data, n) {
    data.push(n & 0xff, (n >>> 8) & 0xff, (n >>> 16) & 0xff, (n >>> 24) & 0xff);
  }
 
  //  for reasons that are not entirely clear the order of RGBA value is BGRA because of the selection of ARGB which is 'BGRA' in the little endian format which RIFF consistenly adheres too.
  this.appendRGBA = function(data, n) {
    data.push((n >>> 16) & 0xff,(n >>> 8) & 0xff, n & 0xff, (n >>> 24) & 0xff);
  }
  
  //appends individual's voxel data to a sequence of binary data. each xyzi component is 1 byte long. This is ensured by the typearray of unsigned 8 bit int later in the code.
  this.appendVoxel = function(data, key) {
    var v = key.split("_");
    data.push(v[0], v[1], v[2], this.voxels[key]);
  }

  // a function for the orchestrates the exporting of programatically generated data. Seralizes into RIFF format and calls helper function that converts to blob and then URL and triggers download from that URL location.
  this.export = function(filename) {
    var data = [];
    
    //identifies that binary stream as type VOX
    this.appendString(data, "VOX ");

    //identifies the version of the VOX format being used
    this.appendUInt32(data, 150);

    //the begining of the first and root chunk called 'MAIN'. This chunk will have zero bytes of data aside from its children which will have the total number of voxels*4 bytes (this.vcount*4) + 0x400 (1024 =  256*4 [RBGA]) bytes for the color pallette + 0x034 (52) bytes for all of the extra child info not counting voxel and pallette data which has already been accounted for (headers, mainchunk size, child chunk size, etc...) 
    this.appendString(data, "MAIN");
    this.appendUInt32(data, 0);
    this.appendUInt32(data, this.vcount * 4 + 0x028);

    // the chunk with id 'PACK' would appear here but is optional. Its absence indicates that there is only one model in the VOX file.
    //......
    //......
    //......

    // the begining of the 'SIZE' chunk. This indicates the spactial dimensions in unit voxels that the voxels in the VOX file occupy. Each of the dimensions are specified as 32 bit unsigned integers or 4 bytes. Since there are three dimensions this means there will be a 12 bytes total and hence the size of the chunk. There will be no child chunks so this will be set to zero.
    this.appendString(data, "SIZE");
    this.appendUInt32(data, 12);
    this.appendUInt32(data, 0);
    this.appendUInt32(data, this.X);
    this.appendUInt32(data, this.Y);
    this.appendUInt32(data, this.Z);

    // the begining of the 'XYZI' chunk. This indicates the positions and colors of all of the respective voxels inside the VOX file as well as the total number of those respective voxels. There will be no child data and the data itself is this.vcount* 4 + 4. this.vcount because there are four bytes for each voxel-- one for each of the three spacial dimensions and one for the color index. An additional 4 bytes is required for the 32 bit unsigned integer indicating the total number of voxels.
    this.appendString(data, "XYZI");
    this.appendUInt32(data, 4 + this.vcount * 4);
    this.appendUInt32(data, 0);
    this.appendUInt32(data, this.vcount);
    for (var key in this.voxels) {
      this.appendVoxel(data, key);
    }

    //Begining of RGBA chunk. This will have a size of 256x4 = 1024 (0x400) bytes. This chunk is not needed and magica voxel will default to a standard palette specified internally if absent.
    // this.appendString(data, "RGBA");
    // this.appendUInt32(data, 0x400);
    // this.appendUInt32(data, 0);
    // for (var i = 0; i < 256; i++) {
    //     this.appendRGBA(data, this.palette[i]);
    // }

    //store the data as a binary stream and pass it to another function which will then cause the file to be downloaded.
    this.saveByteArray([new Uint8Array(data)], filename)
    return
  }

    //this function will take in a stream of binary data, store it inside of a newly created blob object and then convert it into a URL which will the be used as the destination of an auto download.
  this.saveByteArray = (function() {
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style = "display: none";
    return function(data, name) {
      var blob = new Blob(data, {
          type: "octet/stream"
        }),
        url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = name;
      a.click();
      window.URL.revokeObjectURL(url);
    };
  }());
}

//This is an example how this class is used:
//create a new Voxel volume (maximum dimensions are 256x256x256 right now)
// var vox = new VOX(2, 2, 2);
// vox.setVoxel(0, 0, 0,1);


//the color palette can be written directly
//format is 0xAARRGGBB
// note that the palette values are offset by 1,
// so setting palette[0] will change the color index #1

document.getElementById("downloadButton").addEventListener("click", function() {
  vox.export('test1.vox');
});